

#### Node runtime 

![[Pasted image 20230917190752.png|400]]

![[Screenshot 2023-09-17 at 7.05.35 PM.png]]

### How does node allow us to run code asynchronously 

Node executes javaScript code, so it has to follow how the language works in begin single threaded , in Node we have one main thread which runs the V8 engine, our javaScript code including the node APIs as well as a super important part of Libuv ,which is event loop.

![[Screenshot 2023-09-17 at 7.24.54 PM.png|400]]

libuv is written in c which is multithreaded and thus it offers a thread pool which is a collection of threads ( by default 4 threads) which handles asynchronous I/O delegated by node to libuv which is then put on one of the four thread by the event loop.

![[Screenshot 2023-09-17 at 7.25.25 PM.png|7-0]]

The main thread executes the javascript code, when the delegated I/O task is finished on one of the thread in the thread pool , the event loop is notified of the results which then put the to be execute function (call back function )  in the queue. 

In libuv not all asynchronous I/O are executed in thread pool , most network related  async I/O are delegated to the kernel or system which has its own capabilities and threads which when the request is completed notifies the event loop. this leaves the thread pool out of the pictures thus not overflowing the thread pools. 

![[Screenshot 2023-09-17 at 7.32.58 PM.png|400]] ![[Pasted image 20230917191421.png|400]]


- this means as a node developer we don't have to worry about multithreading which simplifies how we write code. node already knows who should do the work to get the job done. its only the code behind node or code behind the OS which has multiple threads and uses those threads to perform input and output tasks. its this internals which allows node to do its non-blocking I/O.


### Phases of Event loop

#### Callback Queues 
![[Screenshot 2023-09-17 at 7.39.08 PM.png|300]]


